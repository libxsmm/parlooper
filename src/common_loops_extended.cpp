/******************************************************************************
* Copyright (c) Intel Corporation - All rights reserved.                      *
* This file is part of the LIBXSMM library.                                   *
*                                                                             *
* For information on the license, see the LICENSE file.                       *
* Further information: https://github.com/libxsmm/libxsmm/                    *
* SPDX-License-Identifier: BSD-3-Clause                                       *
******************************************************************************/
#include <functional>
#include <string>
#include <unordered_map>
#include "threaded_loops.h"
#include <omp.h>

void par_nested_loops_aBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 0;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 0;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 0;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 0;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 0;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 0;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 0;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 0;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 0;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 0;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 0;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 0;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          int idx[13];
          idx[0] = a0;
          idx[1] = b0;
          idx[2] = c0;
          idx[3] = 0;
          idx[4] = 1;
          idx[5] = 1;
          body_func(idx);
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b0;
            idx[2] = c1;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b0;
              idx[2] = c2;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Babc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 0;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 0;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            int idx[13];
            idx[0] = a0;
            idx[1] = b1;
            idx[2] = c0;
            idx[3] = 0;
            idx[4] = 1;
            idx[5] = 1;
            body_func(idx);
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b1;
              idx[2] = c1;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b1;
                idx[2] = c2;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Babcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 0;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 0;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              int idx[13];
              idx[0] = a0;
              idx[1] = b2;
              idx[2] = c0;
              idx[3] = 0;
              idx[4] = 1;
              idx[5] = 1;
              body_func(idx);
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Babcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 0;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 0;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                int idx[13];
                idx[0] = a0;
                idx[1] = b2;
                idx[2] = c1;
                idx[3] = 0;
                idx[4] = 1;
                idx[5] = 1;
                body_func(idx);
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBcbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bacbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bbcacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Bcacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBcacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcaBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBcabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbaBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbacB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbcBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbcaB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcacBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcacbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbcB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbcbB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                #pragma omp for  nowait
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbcBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              #pragma omp for  nowait
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 0;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCbcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcbCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcbcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCcabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbabCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbabcC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcaCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcbaC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcbCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cbcabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Cabcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_Ccbcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcbC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbaCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbabC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                #pragma omp for  nowait
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCbcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 0;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aBCcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abBCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abCBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcbcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_abcBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBbcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_aCBcbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acbcbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acCBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_acBCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_BCcabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bBCcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baBCcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_babcBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_baCBcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacbcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bacBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBbcac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bCBcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcabcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcaBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcacbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbaBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbacCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCBac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbCBca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBCac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbBCca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcaBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcbcaCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcCBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_bcBCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
      for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbacbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBbcbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBabcbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBacbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_CBcabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    #pragma omp for collapse(2)  nowait
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cBCcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbBCcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBbac(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBbca(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbCBcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabCBc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabBCc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbabcCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbaBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbacbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbCBa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbaCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbaBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcbBCa(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCBab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcCBba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcabBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcaBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBCab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cbcBCba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbabc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbacb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbcab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBbcba(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBabcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cCBcbab(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      #pragma omp for collapse(2)  nowait
      for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCBbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabCBcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBCbc(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabBCcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          #pragma omp for collapse(2)  nowait
          for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
            for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbBC(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cabcbCB(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              #pragma omp for collapse(2)  nowait
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caCBbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_caBCbcb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        #pragma omp for collapse(2)  nowait
        for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
          for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbCBb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
              for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

void par_nested_loops_cacbBCb(LoopSpecs *loopSpecs, std::function<void(int *)> body_func, std::function<void()> init_func, std::function<void()> term_func) {
  #pragma omp parallel
  {
    int tid = omp_get_thread_num();
    if (init_func) init_func();
    for (int c0 = loopSpecs[2].start; c0 < loopSpecs[2].end; c0 += loopSpecs[2].block_size[0]) {
      for (int a0 = loopSpecs[0].start; a0 < loopSpecs[0].end; a0 += loopSpecs[0].step) {
        for (int c1 = c0; c1 < c0 + loopSpecs[2].block_size[0]; c1 += loopSpecs[2].block_size[1]) {
          for (int b0 = loopSpecs[1].start; b0 < loopSpecs[1].end; b0 += loopSpecs[1].block_size[0]) {
            #pragma omp for collapse(2)  nowait
            for (int b1 = b0; b1 < b0 + loopSpecs[1].block_size[0]; b1 += loopSpecs[1].block_size[1]) {
              for (int c2 = c1; c2 < c1 + loopSpecs[2].block_size[1]; c2 += loopSpecs[2].step) {
                for (int b2 = b1; b2 < b1 + loopSpecs[1].block_size[1]; b2 += loopSpecs[1].step) {
                  int idx[13];
                  idx[0] = a0;
                  idx[1] = b2;
                  idx[2] = c2;
                  idx[3] = 0;
                  idx[4] = 1;
                  idx[5] = 1;
                  body_func(idx);
                }
              }
            }
          }
        }
      }
    }
    if (term_func) term_func();
  }
}

std::unordered_map<std::string, par_loop_kernel> pre_defined_loops = {
	{"aBc", par_nested_loops_aBc},
	{"acB", par_nested_loops_acB},
	{"Bac", par_nested_loops_Bac},
	{"Bca", par_nested_loops_Bca},
	{"cBa", par_nested_loops_cBa},
	{"caB", par_nested_loops_caB},
	{"abC", par_nested_loops_abC},
	{"aCb", par_nested_loops_aCb},
	{"baC", par_nested_loops_baC},
	{"bCa", par_nested_loops_bCa},
	{"Cba", par_nested_loops_Cba},
	{"Cab", par_nested_loops_Cab},
	{"aBC", par_nested_loops_aBC},
	{"aCB", par_nested_loops_aCB},
	{"BCa", par_nested_loops_BCa},
	{"CBa", par_nested_loops_CBa},
	{"acBc", par_nested_loops_acBc},
	{"Bcac", par_nested_loops_Bcac},
	{"cBac", par_nested_loops_cBac},
	{"cBca", par_nested_loops_cBca},
	{"caBc", par_nested_loops_caBc},
	{"cacB", par_nested_loops_cacB},
	{"abCc", par_nested_loops_abCc},
	{"abcC", par_nested_loops_abcC},
	{"aCbc", par_nested_loops_aCbc},
	{"aCcb", par_nested_loops_aCcb},
	{"acCb", par_nested_loops_acCb},
	{"acbC", par_nested_loops_acbC},
	{"baCc", par_nested_loops_baCc},
	{"bacC", par_nested_loops_bacC},
	{"bCac", par_nested_loops_bCac},
	{"bCca", par_nested_loops_bCca},
	{"bcCa", par_nested_loops_bcCa},
	{"bcaC", par_nested_loops_bcaC},
	{"Cbac", par_nested_loops_Cbac},
	{"Cbca", par_nested_loops_Cbca},
	{"Cabc", par_nested_loops_Cabc},
	{"Cacb", par_nested_loops_Cacb},
	{"Ccab", par_nested_loops_Ccab},
	{"Ccba", par_nested_loops_Ccba},
	{"cbCa", par_nested_loops_cbCa},
	{"cbaC", par_nested_loops_cbaC},
	{"cCba", par_nested_loops_cCba},
	{"cCab", par_nested_loops_cCab},
	{"caCb", par_nested_loops_caCb},
	{"cabC", par_nested_loops_cabC},
	{"aBCc", par_nested_loops_aBCc},
	{"aCBc", par_nested_loops_aCBc},
	{"acCB", par_nested_loops_acCB},
	{"acBC", par_nested_loops_acBC},
	{"BCac", par_nested_loops_BCac},
	{"BCca", par_nested_loops_BCca},
	{"CBac", par_nested_loops_CBac},
	{"CBca", par_nested_loops_CBca},
	{"cBCa", par_nested_loops_cBCa},
	{"cCBa", par_nested_loops_cCBa},
	{"caCB", par_nested_loops_caCB},
	{"caBC", par_nested_loops_caBC},
	{"cBcac", par_nested_loops_cBcac},
	{"cacBc", par_nested_loops_cacBc},
	{"abcCc", par_nested_loops_abcCc},
	{"aCcbc", par_nested_loops_aCcbc},
	{"acCbc", par_nested_loops_acCbc},
	{"acCcb", par_nested_loops_acCcb},
	{"acbCc", par_nested_loops_acbCc},
	{"acbcC", par_nested_loops_acbcC},
	{"bacCc", par_nested_loops_bacCc},
	{"bCcac", par_nested_loops_bCcac},
	{"bcCac", par_nested_loops_bcCac},
	{"bcCca", par_nested_loops_bcCca},
	{"bcaCc", par_nested_loops_bcaCc},
	{"bcacC", par_nested_loops_bcacC},
	{"Cbcac", par_nested_loops_Cbcac},
	{"Cacbc", par_nested_loops_Cacbc},
	{"Ccabc", par_nested_loops_Ccabc},
	{"Ccacb", par_nested_loops_Ccacb},
	{"Ccbac", par_nested_loops_Ccbac},
	{"Ccbca", par_nested_loops_Ccbca},
	{"cbCac", par_nested_loops_cbCac},
	{"cbCca", par_nested_loops_cbCca},
	{"cbaCc", par_nested_loops_cbaCc},
	{"cbacC", par_nested_loops_cbacC},
	{"cbcaC", par_nested_loops_cbcaC},
	{"cbcCa", par_nested_loops_cbcCa},
	{"cCbac", par_nested_loops_cCbac},
	{"cCbca", par_nested_loops_cCbca},
	{"cCabc", par_nested_loops_cCabc},
	{"cCacb", par_nested_loops_cCacb},
	{"cCcab", par_nested_loops_cCcab},
	{"cCcba", par_nested_loops_cCcba},
	{"caCbc", par_nested_loops_caCbc},
	{"caCcb", par_nested_loops_caCcb},
	{"cabCc", par_nested_loops_cabCc},
	{"cabcC", par_nested_loops_cabcC},
	{"cacbC", par_nested_loops_cacbC},
	{"cacCb", par_nested_loops_cacCb},
	{"acCBc", par_nested_loops_acCBc},
	{"acBCc", par_nested_loops_acBCc},
	{"BCcac", par_nested_loops_BCcac},
	{"CBcac", par_nested_loops_CBcac},
	{"cBCac", par_nested_loops_cBCac},
	{"cBCca", par_nested_loops_cBCca},
	{"cCBac", par_nested_loops_cCBac},
	{"cCBca", par_nested_loops_cCBca},
	{"caCBc", par_nested_loops_caCBc},
	{"caBCc", par_nested_loops_caBCc},
	{"cacBC", par_nested_loops_cacBC},
	{"cacCB", par_nested_loops_cacCB},
	{"aBbc", par_nested_loops_aBbc},
	{"aBcb", par_nested_loops_aBcb},
	{"abBc", par_nested_loops_abBc},
	{"abcB", par_nested_loops_abcB},
	{"acbB", par_nested_loops_acbB},
	{"acBb", par_nested_loops_acBb},
	{"Babc", par_nested_loops_Babc},
	{"Bacb", par_nested_loops_Bacb},
	{"Bbac", par_nested_loops_Bbac},
	{"Bbca", par_nested_loops_Bbca},
	{"Bcba", par_nested_loops_Bcba},
	{"Bcab", par_nested_loops_Bcab},
	{"bBac", par_nested_loops_bBac},
	{"bBca", par_nested_loops_bBca},
	{"baBc", par_nested_loops_baBc},
	{"bacB", par_nested_loops_bacB},
	{"bcaB", par_nested_loops_bcaB},
	{"bcBa", par_nested_loops_bcBa},
	{"cBba", par_nested_loops_cBba},
	{"cBab", par_nested_loops_cBab},
	{"cbBa", par_nested_loops_cbBa},
	{"cbaB", par_nested_loops_cbaB},
	{"cabB", par_nested_loops_cabB},
	{"caBb", par_nested_loops_caBb},
	{"abCb", par_nested_loops_abCb},
	{"babC", par_nested_loops_babC},
	{"baCb", par_nested_loops_baCb},
	{"bCba", par_nested_loops_bCba},
	{"bCab", par_nested_loops_bCab},
	{"Cbab", par_nested_loops_Cbab},
	{"aBCb", par_nested_loops_aBCb},
	{"abBC", par_nested_loops_abBC},
	{"abCB", par_nested_loops_abCB},
	{"aCBb", par_nested_loops_aCBb},
	{"BCba", par_nested_loops_BCba},
	{"BCab", par_nested_loops_BCab},
	{"bBCa", par_nested_loops_bBCa},
	{"baBC", par_nested_loops_baBC},
	{"baCB", par_nested_loops_baCB},
	{"bCBa", par_nested_loops_bCBa},
	{"CBba", par_nested_loops_CBba},
	{"CBab", par_nested_loops_CBab},
	{"aBcbc", par_nested_loops_aBcbc},
	{"abcBc", par_nested_loops_abcBc},
	{"acbBc", par_nested_loops_acbBc},
	{"acbcB", par_nested_loops_acbcB},
	{"acBbc", par_nested_loops_acBbc},
	{"acBcb", par_nested_loops_acBcb},
	{"Bacbc", par_nested_loops_Bacbc},
	{"Bbcac", par_nested_loops_Bbcac},
	{"Bcbac", par_nested_loops_Bcbac},
	{"Bcbca", par_nested_loops_Bcbca},
	{"Bcabc", par_nested_loops_Bcabc},
	{"Bcacb", par_nested_loops_Bcacb},
	{"bBcac", par_nested_loops_bBcac},
	{"bacBc", par_nested_loops_bacBc},
	{"bcaBc", par_nested_loops_bcaBc},
	{"bcacB", par_nested_loops_bcacB},
	{"bcBac", par_nested_loops_bcBac},
	{"bcBca", par_nested_loops_bcBca},
	{"cBbac", par_nested_loops_cBbac},
	{"cBbca", par_nested_loops_cBbca},
	{"cBabc", par_nested_loops_cBabc},
	{"cBacb", par_nested_loops_cBacb},
	{"cBcab", par_nested_loops_cBcab},
	{"cBcba", par_nested_loops_cBcba},
	{"cbBac", par_nested_loops_cbBac},
	{"cbBca", par_nested_loops_cbBca},
	{"cbaBc", par_nested_loops_cbaBc},
	{"cbacB", par_nested_loops_cbacB},
	{"cbcaB", par_nested_loops_cbcaB},
	{"cbcBa", par_nested_loops_cbcBa},
	{"cabBc", par_nested_loops_cabBc},
	{"cabcB", par_nested_loops_cabcB},
	{"caBbc", par_nested_loops_caBbc},
	{"caBcb", par_nested_loops_caBcb},
	{"cacBb", par_nested_loops_cacBb},
	{"cacbB", par_nested_loops_cacbB},
	{"abCbc", par_nested_loops_abCbc},
	{"abCcb", par_nested_loops_abCcb},
	{"abcCb", par_nested_loops_abcCb},
	{"abcbC", par_nested_loops_abcbC},
	{"aCbcb", par_nested_loops_aCbcb},
	{"acbCb", par_nested_loops_acbCb},
	{"babCc", par_nested_loops_babCc},
	{"babcC", par_nested_loops_babcC},
	{"baCbc", par_nested_loops_baCbc},
	{"baCcb", par_nested_loops_baCcb},
	{"bacCb", par_nested_loops_bacCb},
	{"bacbC", par_nested_loops_bacbC},
	{"bCbac", par_nested_loops_bCbac},
	{"bCbca", par_nested_loops_bCbca},
	{"bCabc", par_nested_loops_bCabc},
	{"bCacb", par_nested_loops_bCacb},
	{"bCcab", par_nested_loops_bCcab},
	{"bCcba", par_nested_loops_bCcba},
	{"bcbCa", par_nested_loops_bcbCa},
	{"bcbaC", par_nested_loops_bcbaC},
	{"bcCba", par_nested_loops_bcCba},
	{"bcCab", par_nested_loops_bcCab},
	{"bcaCb", par_nested_loops_bcaCb},
	{"bcabC", par_nested_loops_bcabC},
	{"Cbabc", par_nested_loops_Cbabc},
	{"Cbacb", par_nested_loops_Cbacb},
	{"Cbcab", par_nested_loops_Cbcab},
	{"Cbcba", par_nested_loops_Cbcba},
	{"Cabcb", par_nested_loops_Cabcb},
	{"Ccbab", par_nested_loops_Ccbab},
	{"cbCba", par_nested_loops_cbCba},
	{"cbCab", par_nested_loops_cbCab},
	{"cbaCb", par_nested_loops_cbaCb},
	{"cbabC", par_nested_loops_cbabC},
	{"cCbab", par_nested_loops_cCbab},
	{"cabCb", par_nested_loops_cabCb},
	{"aBCbc", par_nested_loops_aBCbc},
	{"aBCcb", par_nested_loops_aBCcb},
	{"abBCc", par_nested_loops_abBCc},
	{"abCBc", par_nested_loops_abCBc},
	{"abcCB", par_nested_loops_abcCB},
	{"abcBC", par_nested_loops_abcBC},
	{"aCBbc", par_nested_loops_aCBbc},
	{"aCBcb", par_nested_loops_aCBcb},
	{"acbCB", par_nested_loops_acbCB},
	{"acbBC", par_nested_loops_acbBC},
	{"acCBb", par_nested_loops_acCBb},
	{"acBCb", par_nested_loops_acBCb},
	{"BCbac", par_nested_loops_BCbac},
	{"BCbca", par_nested_loops_BCbca},
	{"BCabc", par_nested_loops_BCabc},
	{"BCacb", par_nested_loops_BCacb},
	{"BCcab", par_nested_loops_BCcab},
	{"BCcba", par_nested_loops_BCcba},
	{"bBCac", par_nested_loops_bBCac},
	{"bBCca", par_nested_loops_bBCca},
	{"baBCc", par_nested_loops_baBCc},
	{"baCBc", par_nested_loops_baCBc},
	{"bacCB", par_nested_loops_bacCB},
	{"bacBC", par_nested_loops_bacBC},
	{"bCBac", par_nested_loops_bCBac},
	{"bCBca", par_nested_loops_bCBca},
	{"bcaCB", par_nested_loops_bcaCB},
	{"bcaBC", par_nested_loops_bcaBC},
	{"bcCBa", par_nested_loops_bcCBa},
	{"bcBCa", par_nested_loops_bcBCa},
	{"CBbac", par_nested_loops_CBbac},
	{"CBbca", par_nested_loops_CBbca},
	{"CBabc", par_nested_loops_CBabc},
	{"CBacb", par_nested_loops_CBacb},
	{"CBcab", par_nested_loops_CBcab},
	{"CBcba", par_nested_loops_CBcba},
	{"cBCba", par_nested_loops_cBCba},
	{"cBCab", par_nested_loops_cBCab},
	{"cbBCa", par_nested_loops_cbBCa},
	{"cbCBa", par_nested_loops_cbCBa},
	{"cbaCB", par_nested_loops_cbaCB},
	{"cbaBC", par_nested_loops_cbaBC},
	{"cCBba", par_nested_loops_cCBba},
	{"cCBab", par_nested_loops_cCBab},
	{"cabCB", par_nested_loops_cabCB},
	{"cabBC", par_nested_loops_cabBC},
	{"caCBb", par_nested_loops_caCBb},
	{"caBCb", par_nested_loops_caBCb},
	{"acbcBc", par_nested_loops_acbcBc},
	{"acBcbc", par_nested_loops_acBcbc},
	{"Bcbcac", par_nested_loops_Bcbcac},
	{"Bcacbc", par_nested_loops_Bcacbc},
	{"bcacBc", par_nested_loops_bcacBc},
	{"bcBcac", par_nested_loops_bcBcac},
	{"cBbcac", par_nested_loops_cBbcac},
	{"cBacbc", par_nested_loops_cBacbc},
	{"cBcabc", par_nested_loops_cBcabc},
	{"cBcacb", par_nested_loops_cBcacb},
	{"cBcbac", par_nested_loops_cBcbac},
	{"cBcbca", par_nested_loops_cBcbca},
	{"cbBcac", par_nested_loops_cbBcac},
	{"cbacBc", par_nested_loops_cbacBc},
	{"cbcaBc", par_nested_loops_cbcaBc},
	{"cbcacB", par_nested_loops_cbcacB},
	{"cbcBac", par_nested_loops_cbcBac},
	{"cbcBca", par_nested_loops_cbcBca},
	{"cabcBc", par_nested_loops_cabcBc},
	{"caBcbc", par_nested_loops_caBcbc},
	{"cacBbc", par_nested_loops_cacBbc},
	{"cacBcb", par_nested_loops_cacBcb},
	{"cacbBc", par_nested_loops_cacbBc},
	{"cacbcB", par_nested_loops_cacbcB},
	{"abCcbc", par_nested_loops_abCcbc},
	{"abcCbc", par_nested_loops_abcCbc},
	{"abcCcb", par_nested_loops_abcCcb},
	{"abcbCc", par_nested_loops_abcbCc},
	{"abcbcC", par_nested_loops_abcbcC},
	{"aCbcbc", par_nested_loops_aCbcbc},
	{"aCcbcb", par_nested_loops_aCcbcb},
	{"acbCbc", par_nested_loops_acbCbc},
	{"acbCcb", par_nested_loops_acbCcb},
	{"acbcbC", par_nested_loops_acbcbC},
	{"acbcCb", par_nested_loops_acbcCb},
	{"acCbcb", par_nested_loops_acCbcb},
	{"babcCc", par_nested_loops_babcCc},
	{"baCcbc", par_nested_loops_baCcbc},
	{"bacCbc", par_nested_loops_bacCbc},
	{"bacCcb", par_nested_loops_bacCcb},
	{"bacbCc", par_nested_loops_bacbCc},
	{"bacbcC", par_nested_loops_bacbcC},
	{"bCbcac", par_nested_loops_bCbcac},
	{"bCacbc", par_nested_loops_bCacbc},
	{"bCcabc", par_nested_loops_bCcabc},
	{"bCcacb", par_nested_loops_bCcacb},
	{"bCcbac", par_nested_loops_bCcbac},
	{"bCcbca", par_nested_loops_bCcbca},
	{"bcbCac", par_nested_loops_bcbCac},
	{"bcbCca", par_nested_loops_bcbCca},
	{"bcbaCc", par_nested_loops_bcbaCc},
	{"bcbacC", par_nested_loops_bcbacC},
	{"bcbcaC", par_nested_loops_bcbcaC},
	{"bcbcCa", par_nested_loops_bcbcCa},
	{"bcCbac", par_nested_loops_bcCbac},
	{"bcCbca", par_nested_loops_bcCbca},
	{"bcCabc", par_nested_loops_bcCabc},
	{"bcCacb", par_nested_loops_bcCacb},
	{"bcCcab", par_nested_loops_bcCcab},
	{"bcCcba", par_nested_loops_bcCcba},
	{"bcaCbc", par_nested_loops_bcaCbc},
	{"bcaCcb", par_nested_loops_bcaCcb},
	{"bcabCc", par_nested_loops_bcabCc},
	{"bcabcC", par_nested_loops_bcabcC},
	{"bcacbC", par_nested_loops_bcacbC},
	{"bcacCb", par_nested_loops_bcacCb},
	{"Cbacbc", par_nested_loops_Cbacbc},
	{"Cbcabc", par_nested_loops_Cbcabc},
	{"Cbcacb", par_nested_loops_Cbcacb},
	{"Cbcbac", par_nested_loops_Cbcbac},
	{"Cbcbca", par_nested_loops_Cbcbca},
	{"Cabcbc", par_nested_loops_Cabcbc},
	{"Cacbcb", par_nested_loops_Cacbcb},
	{"Ccbabc", par_nested_loops_Ccbabc},
	{"Ccbacb", par_nested_loops_Ccbacb},
	{"Ccbcba", par_nested_loops_Ccbcba},
	{"Ccbcab", par_nested_loops_Ccbcab},
	{"Ccabcb", par_nested_loops_Ccabcb},
	{"cbCbac", par_nested_loops_cbCbac},
	{"cbCbca", par_nested_loops_cbCbca},
	{"cbCabc", par_nested_loops_cbCabc},
	{"cbCacb", par_nested_loops_cbCacb},
	{"cbCcab", par_nested_loops_cbCcab},
	{"cbCcba", par_nested_loops_cbCcba},
	{"cbaCbc", par_nested_loops_cbaCbc},
	{"cbaCcb", par_nested_loops_cbaCcb},
	{"cbabCc", par_nested_loops_cbabCc},
	{"cbabcC", par_nested_loops_cbabcC},
	{"cbacbC", par_nested_loops_cbacbC},
	{"cbacCb", par_nested_loops_cbacCb},
	{"cbcCab", par_nested_loops_cbcCab},
	{"cbcCba", par_nested_loops_cbcCba},
	{"cbcaCb", par_nested_loops_cbcaCb},
	{"cbcabC", par_nested_loops_cbcabC},
	{"cbcbaC", par_nested_loops_cbcbaC},
	{"cbcbCa", par_nested_loops_cbcbCa},
	{"cCbabc", par_nested_loops_cCbabc},
	{"cCbacb", par_nested_loops_cCbacb},
	{"cCbcab", par_nested_loops_cCbcab},
	{"cCbcba", par_nested_loops_cCbcba},
	{"cCabcb", par_nested_loops_cCabcb},
	{"cCcbab", par_nested_loops_cCcbab},
	{"cabCbc", par_nested_loops_cabCbc},
	{"cabCcb", par_nested_loops_cabCcb},
	{"cabcbC", par_nested_loops_cabcbC},
	{"cabcCb", par_nested_loops_cabcCb},
	{"caCbcb", par_nested_loops_caCbcb},
	{"cacbCb", par_nested_loops_cacbCb},
	{"aBCcbc", par_nested_loops_aBCcbc},
	{"abcCBc", par_nested_loops_abcCBc},
	{"abcBCc", par_nested_loops_abcBCc},
	{"aCBcbc", par_nested_loops_aCBcbc},
	{"acbCBc", par_nested_loops_acbCBc},
	{"acbBCc", par_nested_loops_acbBCc},
	{"acbcBC", par_nested_loops_acbcBC},
	{"acbcCB", par_nested_loops_acbcCB},
	{"acCBbc", par_nested_loops_acCBbc},
	{"acCBcb", par_nested_loops_acCBcb},
	{"acBCbc", par_nested_loops_acBCbc},
	{"acBCcb", par_nested_loops_acBCcb},
	{"BCbcac", par_nested_loops_BCbcac},
	{"BCacbc", par_nested_loops_BCacbc},
	{"BCcabc", par_nested_loops_BCcabc},
	{"BCcacb", par_nested_loops_BCcacb},
	{"BCcbac", par_nested_loops_BCcbac},
	{"BCcbca", par_nested_loops_BCcbca},
	{"bBCcac", par_nested_loops_bBCcac},
	{"bacCBc", par_nested_loops_bacCBc},
	{"bacBCc", par_nested_loops_bacBCc},
	{"bCBcac", par_nested_loops_bCBcac},
	{"bcaCBc", par_nested_loops_bcaCBc},
	{"bcaBCc", par_nested_loops_bcaBCc},
	{"bcacBC", par_nested_loops_bcacBC},
	{"bcacCB", par_nested_loops_bcacCB},
	{"bcCBac", par_nested_loops_bcCBac},
	{"bcCBca", par_nested_loops_bcCBca},
	{"bcBCac", par_nested_loops_bcBCac},
	{"bcBCca", par_nested_loops_bcBCca},
	{"CBbcac", par_nested_loops_CBbcac},
	{"CBacbc", par_nested_loops_CBacbc},
	{"CBcabc", par_nested_loops_CBcabc},
	{"CBcacb", par_nested_loops_CBcacb},
	{"CBcbac", par_nested_loops_CBcbac},
	{"CBcbca", par_nested_loops_CBcbca},
	{"cBCbac", par_nested_loops_cBCbac},
	{"cBCbca", par_nested_loops_cBCbca},
	{"cBCabc", par_nested_loops_cBCabc},
	{"cBCacb", par_nested_loops_cBCacb},
	{"cBCcab", par_nested_loops_cBCcab},
	{"cBCcba", par_nested_loops_cBCcba},
	{"cbBCac", par_nested_loops_cbBCac},
	{"cbBCca", par_nested_loops_cbBCca},
	{"cbCBac", par_nested_loops_cbCBac},
	{"cbCBca", par_nested_loops_cbCBca},
	{"cbaCBc", par_nested_loops_cbaCBc},
	{"cbaBCc", par_nested_loops_cbaBCc},
	{"cbacBC", par_nested_loops_cbacBC},
	{"cbacCB", par_nested_loops_cbacCB},
	{"cbcCBa", par_nested_loops_cbcCBa},
	{"cbcaCB", par_nested_loops_cbcaCB},
	{"cbcaBC", par_nested_loops_cbcaBC},
	{"cbcBCa", par_nested_loops_cbcBCa},
	{"cCBbac", par_nested_loops_cCBbac},
	{"cCBbca", par_nested_loops_cCBbca},
	{"cCBabc", par_nested_loops_cCBabc},
	{"cCBacb", par_nested_loops_cCBacb},
	{"cCBcab", par_nested_loops_cCBcab},
	{"cCBcba", par_nested_loops_cCBcba},
	{"cabCBc", par_nested_loops_cabCBc},
	{"cabBCc", par_nested_loops_cabBCc},
	{"cabcBC", par_nested_loops_cabcBC},
	{"cabcCB", par_nested_loops_cabcCB},
	{"caCBbc", par_nested_loops_caCBbc},
	{"caCBcb", par_nested_loops_caCBcb},
	{"caBCbc", par_nested_loops_caBCbc},
	{"caBCcb", par_nested_loops_caBCcb},
	{"cacCBb", par_nested_loops_cacCBb},
	{"cacBCb", par_nested_loops_cacBCb},
	{"cacbBC", par_nested_loops_cacbBC},
	{"cacbCB", par_nested_loops_cacbCB},
	{"aBbcb", par_nested_loops_aBbcb},
	{"abBbc", par_nested_loops_abBbc},
	{"abBcb", par_nested_loops_abBcb},
	{"abcbB", par_nested_loops_abcbB},
	{"abcBb", par_nested_loops_abcBb},
	{"acbBb", par_nested_loops_acbBb},
	{"Babcb", par_nested_loops_Babcb},
	{"Bbabc", par_nested_loops_Bbabc},
	{"Bbacb", par_nested_loops_Bbacb},
	{"Bbcba", par_nested_loops_Bbcba},
	{"Bbcab", par_nested_loops_Bbcab},
	{"Bcbab", par_nested_loops_Bcbab},
	{"bBabc", par_nested_loops_bBabc},
	{"bBacb", par_nested_loops_bBacb},
	{"bBbac", par_nested_loops_bBbac},
	{"bBbca", par_nested_loops_bBbca},
	{"bBcba", par_nested_loops_bBcba},
	{"bBcab", par_nested_loops_bBcab},
	{"baBbc", par_nested_loops_baBbc},
	{"baBcb", par_nested_loops_baBcb},
	{"babBc", par_nested_loops_babBc},
	{"babcB", par_nested_loops_babcB},
	{"bacbB", par_nested_loops_bacbB},
	{"bacBb", par_nested_loops_bacBb},
	{"bcabB", par_nested_loops_bcabB},
	{"bcaBb", par_nested_loops_bcaBb},
	{"bcbaB", par_nested_loops_bcbaB},
	{"bcbBa", par_nested_loops_bcbBa},
	{"bcBba", par_nested_loops_bcBba},
	{"bcBab", par_nested_loops_bcBab},
	{"cBbab", par_nested_loops_cBbab},
	{"cbBba", par_nested_loops_cbBba},
	{"cbBab", par_nested_loops_cbBab},
	{"cbabB", par_nested_loops_cbabB},
	{"cbaBb", par_nested_loops_cbaBb},
	{"cabBb", par_nested_loops_cabBb},
	{"babCb", par_nested_loops_babCb},
	{"bCbab", par_nested_loops_bCbab},
	{"abBCb", par_nested_loops_abBCb},
	{"abCBb", par_nested_loops_abCBb},
	{"BCbab", par_nested_loops_BCbab},
	{"bBCba", par_nested_loops_bBCba},
	{"bBCab", par_nested_loops_bBCab},
	{"baBCb", par_nested_loops_baBCb},
	{"babBC", par_nested_loops_babBC},
	{"babCB", par_nested_loops_babCB},
	{"baCBb", par_nested_loops_baCBb},
	{"bCBba", par_nested_loops_bCBba},
	{"bCBab", par_nested_loops_bCBab},
	{"CBbab", par_nested_loops_CBbab},
	{"aBbcbc", par_nested_loops_aBbcbc},
	{"aBcbcb", par_nested_loops_aBcbcb},
	{"abBcbc", par_nested_loops_abBcbc},
	{"abcbBc", par_nested_loops_abcbBc},
	{"abcbcB", par_nested_loops_abcbcB},
	{"abcBbc", par_nested_loops_abcBbc},
	{"abcBcb", par_nested_loops_abcBcb},
	{"acbBbc", par_nested_loops_acbBbc},
	{"acbBcb", par_nested_loops_acbBcb},
	{"acbcBb", par_nested_loops_acbcBb},
	{"acbcbB", par_nested_loops_acbcbB},
	{"acBbcb", par_nested_loops_acBbcb},
	{"Babcbc", par_nested_loops_Babcbc},
	{"Bacbcb", par_nested_loops_Bacbcb},
	{"Bbacbc", par_nested_loops_Bbacbc},
	{"Bbcbac", par_nested_loops_Bbcbac},
	{"Bbcbca", par_nested_loops_Bbcbca},
	{"Bbcabc", par_nested_loops_Bbcabc},
	{"Bbcacb", par_nested_loops_Bbcacb},
	{"Bcbabc", par_nested_loops_Bcbabc},
	{"Bcbacb", par_nested_loops_Bcbacb},
	{"Bcbcab", par_nested_loops_Bcbcab},
	{"Bcbcba", par_nested_loops_Bcbcba},
	{"Bcabcb", par_nested_loops_Bcabcb},
	{"bBacbc", par_nested_loops_bBacbc},
	{"bBbcac", par_nested_loops_bBbcac},
	{"bBcbac", par_nested_loops_bBcbac},
	{"bBcbca", par_nested_loops_bBcbca},
	{"bBcabc", par_nested_loops_bBcabc},
	{"bBcacb", par_nested_loops_bBcacb},
	{"baBcbc", par_nested_loops_baBcbc},
	{"babcBc", par_nested_loops_babcBc},
	{"bacbBc", par_nested_loops_bacbBc},
	{"bacbcB", par_nested_loops_bacbcB},
	{"bacBbc", par_nested_loops_bacBbc},
	{"bacBcb", par_nested_loops_bacBcb},
	{"bcabBc", par_nested_loops_bcabBc},
	{"bcabcB", par_nested_loops_bcabcB},
	{"bcaBbc", par_nested_loops_bcaBbc},
	{"bcaBcb", par_nested_loops_bcaBcb},
	{"bcacBb", par_nested_loops_bcacBb},
	{"bcacbB", par_nested_loops_bcacbB},
	{"bcbaBc", par_nested_loops_bcbaBc},
	{"bcbacB", par_nested_loops_bcbacB},
	{"bcbBac", par_nested_loops_bcbBac},
	{"bcbBca", par_nested_loops_bcbBca},
	{"bcbcBa", par_nested_loops_bcbcBa},
	{"bcbcaB", par_nested_loops_bcbcaB},
	{"bcBbac", par_nested_loops_bcBbac},
	{"bcBbca", par_nested_loops_bcBbca},
	{"bcBabc", par_nested_loops_bcBabc},
	{"bcBacb", par_nested_loops_bcBacb},
	{"bcBcab", par_nested_loops_bcBcab},
	{"bcBcba", par_nested_loops_bcBcba},
	{"cBbabc", par_nested_loops_cBbabc},
	{"cBbacb", par_nested_loops_cBbacb},
	{"cBbcab", par_nested_loops_cBbcab},
	{"cBbcba", par_nested_loops_cBbcba},
	{"cBabcb", par_nested_loops_cBabcb},
	{"cBcbab", par_nested_loops_cBcbab},
	{"cbBbac", par_nested_loops_cbBbac},
	{"cbBbca", par_nested_loops_cbBbca},
	{"cbBabc", par_nested_loops_cbBabc},
	{"cbBacb", par_nested_loops_cbBacb},
	{"cbBcab", par_nested_loops_cbBcab},
	{"cbBcba", par_nested_loops_cbBcba},
	{"cbabBc", par_nested_loops_cbabBc},
	{"cbabcB", par_nested_loops_cbabcB},
	{"cbaBbc", par_nested_loops_cbaBbc},
	{"cbaBcb", par_nested_loops_cbaBcb},
	{"cbacBb", par_nested_loops_cbacBb},
	{"cbacbB", par_nested_loops_cbacbB},
	{"cbcbaB", par_nested_loops_cbcbaB},
	{"cbcbBa", par_nested_loops_cbcbBa},
	{"cbcabB", par_nested_loops_cbcabB},
	{"cbcaBb", par_nested_loops_cbcaBb},
	{"cbcBab", par_nested_loops_cbcBab},
	{"cbcBba", par_nested_loops_cbcBba},
	{"cabBbc", par_nested_loops_cabBbc},
	{"cabBcb", par_nested_loops_cabBcb},
	{"cabcBb", par_nested_loops_cabcBb},
	{"cabcbB", par_nested_loops_cabcbB},
	{"caBbcb", par_nested_loops_caBbcb},
	{"cacbBb", par_nested_loops_cacbBb},
	{"abCbcb", par_nested_loops_abCbcb},
	{"abcbCb", par_nested_loops_abcbCb},
	{"babCbc", par_nested_loops_babCbc},
	{"babCcb", par_nested_loops_babCcb},
	{"babcCb", par_nested_loops_babcCb},
	{"babcbC", par_nested_loops_babcbC},
	{"baCbcb", par_nested_loops_baCbcb},
	{"bacbCb", par_nested_loops_bacbCb},
	{"bCbabc", par_nested_loops_bCbabc},
	{"bCbacb", par_nested_loops_bCbacb},
	{"bCbcab", par_nested_loops_bCbcab},
	{"bCbcba", par_nested_loops_bCbcba},
	{"bCabcb", par_nested_loops_bCabcb},
	{"bCcbab", par_nested_loops_bCcbab},
	{"bcbCba", par_nested_loops_bcbCba},
	{"bcbCab", par_nested_loops_bcbCab},
	{"bcbaCb", par_nested_loops_bcbaCb},
	{"bcbabC", par_nested_loops_bcbabC},
	{"bcCbab", par_nested_loops_bcCbab},
	{"bcabCb", par_nested_loops_bcabCb},
	{"Cbabcb", par_nested_loops_Cbabcb},
	{"Cbcbab", par_nested_loops_Cbcbab},
	{"cbCbab", par_nested_loops_cbCbab},
	{"cbabCb", par_nested_loops_cbabCb},
	{"aBCbcb", par_nested_loops_aBCbcb},
	{"abBCbc", par_nested_loops_abBCbc},
	{"abBCcb", par_nested_loops_abBCcb},
	{"abCBbc", par_nested_loops_abCBbc},
	{"abCBcb", par_nested_loops_abCBcb},
	{"abcbCB", par_nested_loops_abcbCB},
	{"abcbBC", par_nested_loops_abcbBC},
	{"abcCBb", par_nested_loops_abcCBb},
	{"abcBCb", par_nested_loops_abcBCb},
	{"aCBbcb", par_nested_loops_aCBbcb},
	{"acbCBb", par_nested_loops_acbCBb},
	{"acbBCb", par_nested_loops_acbBCb},
	{"BCbabc", par_nested_loops_BCbabc},
	{"BCbacb", par_nested_loops_BCbacb},
	{"BCbcab", par_nested_loops_BCbcab},
	{"BCbcba", par_nested_loops_BCbcba},
	{"BCabcb", par_nested_loops_BCabcb},
	{"BCcbab", par_nested_loops_BCcbab},
	{"bBCbac", par_nested_loops_bBCbac},
	{"bBCbca", par_nested_loops_bBCbca},
	{"bBCabc", par_nested_loops_bBCabc},
	{"bBCacb", par_nested_loops_bBCacb},
	{"bBCcab", par_nested_loops_bBCcab},
	{"bBCcba", par_nested_loops_bBCcba},
	{"baBCbc", par_nested_loops_baBCbc},
	{"baBCcb", par_nested_loops_baBCcb},
	{"babBCc", par_nested_loops_babBCc},
	{"babCBc", par_nested_loops_babCBc},
	{"babcCB", par_nested_loops_babcCB},
	{"babcBC", par_nested_loops_babcBC},
	{"baCBbc", par_nested_loops_baCBbc},
	{"baCBcb", par_nested_loops_baCBcb},
	{"bacbCB", par_nested_loops_bacbCB},
	{"bacbBC", par_nested_loops_bacbBC},
	{"bacCBb", par_nested_loops_bacCBb},
	{"bacBCb", par_nested_loops_bacBCb},
	{"bCBbac", par_nested_loops_bCBbac},
	{"bCBbca", par_nested_loops_bCBbca},
	{"bCBabc", par_nested_loops_bCBabc},
	{"bCBacb", par_nested_loops_bCBacb},
	{"bCBcab", par_nested_loops_bCBcab},
	{"bCBcba", par_nested_loops_bCBcba},
	{"bcabCB", par_nested_loops_bcabCB},
	{"bcabBC", par_nested_loops_bcabBC},
	{"bcaCBb", par_nested_loops_bcaCBb},
	{"bcaBCb", par_nested_loops_bcaBCb},
	{"bcbaCB", par_nested_loops_bcbaCB},
	{"bcbaBC", par_nested_loops_bcbaBC},
	{"bcbCBa", par_nested_loops_bcbCBa},
	{"bcbBCa", par_nested_loops_bcbBCa},
	{"bcCBab", par_nested_loops_bcCBab},
	{"bcCBba", par_nested_loops_bcCBba},
	{"bcBCba", par_nested_loops_bcBCba},
	{"bcBCab", par_nested_loops_bcBCab},
	{"CBbabc", par_nested_loops_CBbabc},
	{"CBbacb", par_nested_loops_CBbacb},
	{"CBbcab", par_nested_loops_CBbcab},
	{"CBbcba", par_nested_loops_CBbcba},
	{"CBabcb", par_nested_loops_CBabcb},
	{"CBcbab", par_nested_loops_CBcbab},
	{"cBCbab", par_nested_loops_cBCbab},
	{"cbBCba", par_nested_loops_cbBCba},
	{"cbBCab", par_nested_loops_cbBCab},
	{"cbCBba", par_nested_loops_cbCBba},
	{"cbCBab", par_nested_loops_cbCBab},
	{"cbabCB", par_nested_loops_cbabCB},
	{"cbabBC", par_nested_loops_cbabBC},
	{"cbaCBb", par_nested_loops_cbaCBb},
	{"cbaBCb", par_nested_loops_cbaBCb},
	{"cCBbab", par_nested_loops_cCBbab},
	{"cabCBb", par_nested_loops_cabCBb},
	{"cabBCb", par_nested_loops_cabBCb},
	{"aBcbcbc", par_nested_loops_aBcbcbc},
	{"abcbcBc", par_nested_loops_abcbcBc},
	{"abcBcbc", par_nested_loops_abcBcbc},
	{"acbBcbc", par_nested_loops_acbBcbc},
	{"acbcBbc", par_nested_loops_acbcBbc},
	{"acbcBcb", par_nested_loops_acbcBcb},
	{"acbcbBc", par_nested_loops_acbcbBc},
	{"acbcbcB", par_nested_loops_acbcbcB},
	{"acBbcbc", par_nested_loops_acBbcbc},
	{"acBcbcb", par_nested_loops_acBcbcb},
	{"Bacbcbc", par_nested_loops_Bacbcbc},
	{"Bbcbcac", par_nested_loops_Bbcbcac},
	{"Bbcacbc", par_nested_loops_Bbcacbc},
	{"Bcbacbc", par_nested_loops_Bcbacbc},
	{"Bcbcabc", par_nested_loops_Bcbcabc},
	{"Bcbcacb", par_nested_loops_Bcbcacb},
	{"Bcbcbac", par_nested_loops_Bcbcbac},
	{"Bcbcbca", par_nested_loops_Bcbcbca},
	{"Bcabcbc", par_nested_loops_Bcabcbc},
	{"Bcacbcb", par_nested_loops_Bcacbcb},
	{"bBcbcac", par_nested_loops_bBcbcac},
	{"bBcacbc", par_nested_loops_bBcacbc},
	{"bacbcBc", par_nested_loops_bacbcBc},
	{"bacBcbc", par_nested_loops_bacBcbc},
	{"bcabcBc", par_nested_loops_bcabcBc},
	{"bcaBcbc", par_nested_loops_bcaBcbc},
	{"bcacBbc", par_nested_loops_bcacBbc},
	{"bcacBcb", par_nested_loops_bcacBcb},
	{"bcacbBc", par_nested_loops_bcacbBc},
	{"bcacbcB", par_nested_loops_bcacbcB},
	{"bcbacBc", par_nested_loops_bcbacBc},
	{"bcbBcac", par_nested_loops_bcbBcac},
	{"bcbcBac", par_nested_loops_bcbcBac},
	{"bcbcBca", par_nested_loops_bcbcBca},
	{"bcbcaBc", par_nested_loops_bcbcaBc},
	{"bcbcacB", par_nested_loops_bcbcacB},
	{"bcBbcac", par_nested_loops_bcBbcac},
	{"bcBacbc", par_nested_loops_bcBacbc},
	{"bcBcabc", par_nested_loops_bcBcabc},
	{"bcBcacb", par_nested_loops_bcBcacb},
	{"bcBcbac", par_nested_loops_bcBcbac},
	{"bcBcbca", par_nested_loops_bcBcbca},
	{"cBbacbc", par_nested_loops_cBbacbc},
	{"cBbcabc", par_nested_loops_cBbcabc},
	{"cBbcacb", par_nested_loops_cBbcacb},
	{"cBbcbac", par_nested_loops_cBbcbac},
	{"cBbcbca", par_nested_loops_cBbcbca},
	{"cBabcbc", par_nested_loops_cBabcbc},
	{"cBacbcb", par_nested_loops_cBacbcb},
	{"cBcbabc", par_nested_loops_cBcbabc},
	{"cBcbacb", par_nested_loops_cBcbacb},
	{"cBcbcba", par_nested_loops_cBcbcba},
	{"cBcbcab", par_nested_loops_cBcbcab},
	{"cBcabcb", par_nested_loops_cBcabcb},
	{"cbBbcac", par_nested_loops_cbBbcac},
	{"cbBacbc", par_nested_loops_cbBacbc},
	{"cbBcabc", par_nested_loops_cbBcabc},
	{"cbBcacb", par_nested_loops_cbBcacb},
	{"cbBcbac", par_nested_loops_cbBcbac},
	{"cbBcbca", par_nested_loops_cbBcbca},
	{"cbabcBc", par_nested_loops_cbabcBc},
	{"cbaBcbc", par_nested_loops_cbaBcbc},
	{"cbacBbc", par_nested_loops_cbacBbc},
	{"cbacBcb", par_nested_loops_cbacBcb},
	{"cbacbBc", par_nested_loops_cbacbBc},
	{"cbacbcB", par_nested_loops_cbacbcB},
	{"cbcbaBc", par_nested_loops_cbcbaBc},
	{"cbcbacB", par_nested_loops_cbcbacB},
	{"cbcbBac", par_nested_loops_cbcbBac},
	{"cbcbBca", par_nested_loops_cbcbBca},
	{"cbcbcBa", par_nested_loops_cbcbcBa},
	{"cbcbcaB", par_nested_loops_cbcbcaB},
	{"cbcabBc", par_nested_loops_cbcabBc},
	{"cbcabcB", par_nested_loops_cbcabcB},
	{"cbcaBbc", par_nested_loops_cbcaBbc},
	{"cbcaBcb", par_nested_loops_cbcaBcb},
	{"cbcacBb", par_nested_loops_cbcacBb},
	{"cbcacbB", par_nested_loops_cbcacbB},
	{"cbcBabc", par_nested_loops_cbcBabc},
	{"cbcBacb", par_nested_loops_cbcBacb},
	{"cbcBbac", par_nested_loops_cbcBbac},
	{"cbcBbca", par_nested_loops_cbcBbca},
	{"cbcBcba", par_nested_loops_cbcBcba},
	{"cbcBcab", par_nested_loops_cbcBcab},
	{"cabBcbc", par_nested_loops_cabBcbc},
	{"cabcBbc", par_nested_loops_cabcBbc},
	{"cabcBcb", par_nested_loops_cabcBcb},
	{"cabcbBc", par_nested_loops_cabcbBc},
	{"cabcbcB", par_nested_loops_cabcbcB},
	{"caBbcbc", par_nested_loops_caBbcbc},
	{"caBcbcb", par_nested_loops_caBcbcb},
	{"cacbBbc", par_nested_loops_cacbBbc},
	{"cacbBcb", par_nested_loops_cacbBcb},
	{"cacbcbB", par_nested_loops_cacbcbB},
	{"cacbcBb", par_nested_loops_cacbcBb},
	{"cacBbcb", par_nested_loops_cacBbcb},
	{"abCbcbc", par_nested_loops_abCbcbc},
	{"abCcbcb", par_nested_loops_abCcbcb},
	{"abcbCbc", par_nested_loops_abcbCbc},
	{"abcbCcb", par_nested_loops_abcbCcb},
	{"abcbcbC", par_nested_loops_abcbcbC},
	{"abcbcCb", par_nested_loops_abcbcCb},
	{"abcCbcb", par_nested_loops_abcCbcb},
	{"aCbcbcb", par_nested_loops_aCbcbcb},
	{"acbCbcb", par_nested_loops_acbCbcb},
	{"acbcbCb", par_nested_loops_acbcbCb},
	{"babCcbc", par_nested_loops_babCcbc},
	{"babcCbc", par_nested_loops_babcCbc},
	{"babcCcb", par_nested_loops_babcCcb},
	{"babcbCc", par_nested_loops_babcbCc},
	{"babcbcC", par_nested_loops_babcbcC},
	{"baCbcbc", par_nested_loops_baCbcbc},
	{"baCcbcb", par_nested_loops_baCcbcb},
	{"bacbCbc", par_nested_loops_bacbCbc},
	{"bacbCcb", par_nested_loops_bacbCcb},
	{"bacbcbC", par_nested_loops_bacbcbC},
	{"bacbcCb", par_nested_loops_bacbcCb},
	{"bacCbcb", par_nested_loops_bacCbcb},
	{"bCbacbc", par_nested_loops_bCbacbc},
	{"bCbcabc", par_nested_loops_bCbcabc},
	{"bCbcacb", par_nested_loops_bCbcacb},
	{"bCbcbac", par_nested_loops_bCbcbac},
	{"bCbcbca", par_nested_loops_bCbcbca},
	{"bCabcbc", par_nested_loops_bCabcbc},
	{"bCacbcb", par_nested_loops_bCacbcb},
	{"bCcbabc", par_nested_loops_bCcbabc},
	{"bCcbacb", par_nested_loops_bCcbacb},
	{"bCcbcba", par_nested_loops_bCcbcba},
	{"bCcbcab", par_nested_loops_bCcbcab},
	{"bCcabcb", par_nested_loops_bCcabcb},
	{"bcbCbac", par_nested_loops_bcbCbac},
	{"bcbCbca", par_nested_loops_bcbCbca},
	{"bcbCabc", par_nested_loops_bcbCabc},
	{"bcbCacb", par_nested_loops_bcbCacb},
	{"bcbCcab", par_nested_loops_bcbCcab},
	{"bcbCcba", par_nested_loops_bcbCcba},
	{"bcbaCbc", par_nested_loops_bcbaCbc},
	{"bcbaCcb", par_nested_loops_bcbaCcb},
	{"bcbabCc", par_nested_loops_bcbabCc},
	{"bcbabcC", par_nested_loops_bcbabcC},
	{"bcbacbC", par_nested_loops_bcbacbC},
	{"bcbacCb", par_nested_loops_bcbacCb},
	{"bcbcCab", par_nested_loops_bcbcCab},
	{"bcbcCba", par_nested_loops_bcbcCba},
	{"bcbcaCb", par_nested_loops_bcbcaCb},
	{"bcbcabC", par_nested_loops_bcbcabC},
	{"bcbcbaC", par_nested_loops_bcbcbaC},
	{"bcbcbCa", par_nested_loops_bcbcbCa},
	{"bcCbabc", par_nested_loops_bcCbabc},
	{"bcCbacb", par_nested_loops_bcCbacb},
	{"bcCbcab", par_nested_loops_bcCbcab},
	{"bcCbcba", par_nested_loops_bcCbcba},
	{"bcCabcb", par_nested_loops_bcCabcb},
	{"bcCcbab", par_nested_loops_bcCcbab},
	{"bcabCbc", par_nested_loops_bcabCbc},
	{"bcabCcb", par_nested_loops_bcabCcb},
	{"bcabcbC", par_nested_loops_bcabcbC},
	{"bcabcCb", par_nested_loops_bcabcCb},
	{"bcaCbcb", par_nested_loops_bcaCbcb},
	{"bcacbCb", par_nested_loops_bcacbCb},
	{"Cbabcbc", par_nested_loops_Cbabcbc},
	{"Cbacbcb", par_nested_loops_Cbacbcb},
	{"Cbcbabc", par_nested_loops_Cbcbabc},
	{"Cbcbacb", par_nested_loops_Cbcbacb},
	{"Cbcbcba", par_nested_loops_Cbcbcba},
	{"Cbcbcab", par_nested_loops_Cbcbcab},
	{"Cbcabcb", par_nested_loops_Cbcabcb},
	{"Cabcbcb", par_nested_loops_Cabcbcb},
	{"Ccbabcb", par_nested_loops_Ccbabcb},
	{"Ccbcbab", par_nested_loops_Ccbcbab},
	{"cbCbabc", par_nested_loops_cbCbabc},
	{"cbCbacb", par_nested_loops_cbCbacb},
	{"cbCbcab", par_nested_loops_cbCbcab},
	{"cbCbcba", par_nested_loops_cbCbcba},
	{"cbCabcb", par_nested_loops_cbCabcb},
	{"cbCcbab", par_nested_loops_cbCcbab},
	{"cbabCbc", par_nested_loops_cbabCbc},
	{"cbabCcb", par_nested_loops_cbabCcb},
	{"cbabcbC", par_nested_loops_cbabcbC},
	{"cbabcCb", par_nested_loops_cbabcCb},
	{"cbaCbcb", par_nested_loops_cbaCbcb},
	{"cbacbCb", par_nested_loops_cbacbCb},
	{"cbcbCab", par_nested_loops_cbcbCab},
	{"cbcbCba", par_nested_loops_cbcbCba},
	{"cbcbaCb", par_nested_loops_cbcbaCb},
	{"cbcbabC", par_nested_loops_cbcbabC},
	{"cbcCbab", par_nested_loops_cbcCbab},
	{"cbcabCb", par_nested_loops_cbcabCb},
	{"cCbabcb", par_nested_loops_cCbabcb},
	{"cCbcbab", par_nested_loops_cCbcbab},
	{"cabCbcb", par_nested_loops_cabCbcb},
	{"cabcbCb", par_nested_loops_cabcbCb},
	{"aBCbcbc", par_nested_loops_aBCbcbc},
	{"aBCcbcb", par_nested_loops_aBCcbcb},
	{"abBCcbc", par_nested_loops_abBCcbc},
	{"abCBcbc", par_nested_loops_abCBcbc},
	{"abcbCBc", par_nested_loops_abcbCBc},
	{"abcbBCc", par_nested_loops_abcbBCc},
	{"abcbcBC", par_nested_loops_abcbcBC},
	{"abcbcCB", par_nested_loops_abcbcCB},
	{"abcCBbc", par_nested_loops_abcCBbc},
	{"abcCBcb", par_nested_loops_abcCBcb},
	{"abcBCbc", par_nested_loops_abcBCbc},
	{"abcBCcb", par_nested_loops_abcBCcb},
	{"aCBbcbc", par_nested_loops_aCBbcbc},
	{"aCBcbcb", par_nested_loops_aCBcbcb},
	{"acbCBbc", par_nested_loops_acbCBbc},
	{"acbCBcb", par_nested_loops_acbCBcb},
	{"acbBCbc", par_nested_loops_acbBCbc},
	{"acbBCcb", par_nested_loops_acbBCcb},
	{"acbcCBb", par_nested_loops_acbcCBb},
	{"acbcBCb", par_nested_loops_acbcBCb},
	{"acbcbBC", par_nested_loops_acbcbBC},
	{"acbcbCB", par_nested_loops_acbcbCB},
	{"acCBbcb", par_nested_loops_acCBbcb},
	{"acBCbcb", par_nested_loops_acBCbcb},
	{"BCbacbc", par_nested_loops_BCbacbc},
	{"BCbcabc", par_nested_loops_BCbcabc},
	{"BCbcacb", par_nested_loops_BCbcacb},
	{"BCbcbac", par_nested_loops_BCbcbac},
	{"BCbcbca", par_nested_loops_BCbcbca},
	{"BCabcbc", par_nested_loops_BCabcbc},
	{"BCacbcb", par_nested_loops_BCacbcb},
	{"BCcbabc", par_nested_loops_BCcbabc},
	{"BCcbacb", par_nested_loops_BCcbacb},
	{"BCcbcba", par_nested_loops_BCcbcba},
	{"BCcbcab", par_nested_loops_BCcbcab},
	{"BCcabcb", par_nested_loops_BCcabcb},
	{"bBCbcac", par_nested_loops_bBCbcac},
	{"bBCacbc", par_nested_loops_bBCacbc},
	{"bBCcabc", par_nested_loops_bBCcabc},
	{"bBCcacb", par_nested_loops_bBCcacb},
	{"bBCcbac", par_nested_loops_bBCcbac},
	{"bBCcbca", par_nested_loops_bBCcbca},
	{"baBCcbc", par_nested_loops_baBCcbc},
	{"babcCBc", par_nested_loops_babcCBc},
	{"babcBCc", par_nested_loops_babcBCc},
	{"baCBcbc", par_nested_loops_baCBcbc},
	{"bacbCBc", par_nested_loops_bacbCBc},
	{"bacbBCc", par_nested_loops_bacbBCc},
	{"bacbcBC", par_nested_loops_bacbcBC},
	{"bacbcCB", par_nested_loops_bacbcCB},
	{"bacCBbc", par_nested_loops_bacCBbc},
	{"bacCBcb", par_nested_loops_bacCBcb},
	{"bacBCbc", par_nested_loops_bacBCbc},
	{"bacBCcb", par_nested_loops_bacBCcb},
	{"bCBbcac", par_nested_loops_bCBbcac},
	{"bCBacbc", par_nested_loops_bCBacbc},
	{"bCBcabc", par_nested_loops_bCBcabc},
	{"bCBcacb", par_nested_loops_bCBcacb},
	{"bCBcbac", par_nested_loops_bCBcbac},
	{"bCBcbca", par_nested_loops_bCBcbca},
	{"bcabCBc", par_nested_loops_bcabCBc},
	{"bcabBCc", par_nested_loops_bcabBCc},
	{"bcabcBC", par_nested_loops_bcabcBC},
	{"bcabcCB", par_nested_loops_bcabcCB},
	{"bcaCBbc", par_nested_loops_bcaCBbc},
	{"bcaCBcb", par_nested_loops_bcaCBcb},
	{"bcaBCbc", par_nested_loops_bcaBCbc},
	{"bcaBCcb", par_nested_loops_bcaBCcb},
	{"bcacCBb", par_nested_loops_bcacCBb},
	{"bcacBCb", par_nested_loops_bcacBCb},
	{"bcacbBC", par_nested_loops_bcacbBC},
	{"bcacbCB", par_nested_loops_bcacbCB},
	{"bcbaCBc", par_nested_loops_bcbaCBc},
	{"bcbaBCc", par_nested_loops_bcbaBCc},
	{"bcbacBC", par_nested_loops_bcbacBC},
	{"bcbacCB", par_nested_loops_bcbacCB},
	{"bcbCBac", par_nested_loops_bcbCBac},
	{"bcbCBca", par_nested_loops_bcbCBca},
	{"bcbBCac", par_nested_loops_bcbBCac},
	{"bcbBCca", par_nested_loops_bcbBCca},
	{"bcbcCBa", par_nested_loops_bcbcCBa},
	{"bcbcBCa", par_nested_loops_bcbcBCa},
	{"bcbcaBC", par_nested_loops_bcbcaBC},
	{"bcbcaCB", par_nested_loops_bcbcaCB},
	{"bcCBabc", par_nested_loops_bcCBabc},
	{"bcCBacb", par_nested_loops_bcCBacb},
	{"bcCBbac", par_nested_loops_bcCBbac},
	{"bcCBbca", par_nested_loops_bcCBbca},
	{"bcCBcba", par_nested_loops_bcCBcba},
	{"bcCBcab", par_nested_loops_bcCBcab},
	{"bcBCbac", par_nested_loops_bcBCbac},
	{"bcBCbca", par_nested_loops_bcBCbca},
	{"bcBCabc", par_nested_loops_bcBCabc},
	{"bcBCacb", par_nested_loops_bcBCacb},
	{"bcBCcab", par_nested_loops_bcBCcab},
	{"bcBCcba", par_nested_loops_bcBCcba},
	{"CBbacbc", par_nested_loops_CBbacbc},
	{"CBbcabc", par_nested_loops_CBbcabc},
	{"CBbcacb", par_nested_loops_CBbcacb},
	{"CBbcbac", par_nested_loops_CBbcbac},
	{"CBbcbca", par_nested_loops_CBbcbca},
	{"CBabcbc", par_nested_loops_CBabcbc},
	{"CBacbcb", par_nested_loops_CBacbcb},
	{"CBcbabc", par_nested_loops_CBcbabc},
	{"CBcbacb", par_nested_loops_CBcbacb},
	{"CBcbcba", par_nested_loops_CBcbcba},
	{"CBcbcab", par_nested_loops_CBcbcab},
	{"CBcabcb", par_nested_loops_CBcabcb},
	{"cBCbabc", par_nested_loops_cBCbabc},
	{"cBCbacb", par_nested_loops_cBCbacb},
	{"cBCbcab", par_nested_loops_cBCbcab},
	{"cBCbcba", par_nested_loops_cBCbcba},
	{"cBCabcb", par_nested_loops_cBCabcb},
	{"cBCcbab", par_nested_loops_cBCcbab},
	{"cbBCbac", par_nested_loops_cbBCbac},
	{"cbBCbca", par_nested_loops_cbBCbca},
	{"cbBCabc", par_nested_loops_cbBCabc},
	{"cbBCacb", par_nested_loops_cbBCacb},
	{"cbBCcab", par_nested_loops_cbBCcab},
	{"cbBCcba", par_nested_loops_cbBCcba},
	{"cbCBbac", par_nested_loops_cbCBbac},
	{"cbCBbca", par_nested_loops_cbCBbca},
	{"cbCBabc", par_nested_loops_cbCBabc},
	{"cbCBacb", par_nested_loops_cbCBacb},
	{"cbCBcab", par_nested_loops_cbCBcab},
	{"cbCBcba", par_nested_loops_cbCBcba},
	{"cbabCBc", par_nested_loops_cbabCBc},
	{"cbabBCc", par_nested_loops_cbabBCc},
	{"cbabcBC", par_nested_loops_cbabcBC},
	{"cbabcCB", par_nested_loops_cbabcCB},
	{"cbaCBbc", par_nested_loops_cbaCBbc},
	{"cbaCBcb", par_nested_loops_cbaCBcb},
	{"cbaBCbc", par_nested_loops_cbaBCbc},
	{"cbaBCcb", par_nested_loops_cbaBCcb},
	{"cbacCBb", par_nested_loops_cbacCBb},
	{"cbacBCb", par_nested_loops_cbacBCb},
	{"cbacbBC", par_nested_loops_cbacbBC},
	{"cbacbCB", par_nested_loops_cbacbCB},
	{"cbcbCBa", par_nested_loops_cbcbCBa},
	{"cbcbaCB", par_nested_loops_cbcbaCB},
	{"cbcbaBC", par_nested_loops_cbcbaBC},
	{"cbcbBCa", par_nested_loops_cbcbBCa},
	{"cbcCBab", par_nested_loops_cbcCBab},
	{"cbcCBba", par_nested_loops_cbcCBba},
	{"cbcaCBb", par_nested_loops_cbcaCBb},
	{"cbcabCB", par_nested_loops_cbcabCB},
	{"cbcabBC", par_nested_loops_cbcabBC},
	{"cbcaBCb", par_nested_loops_cbcaBCb},
	{"cbcBCab", par_nested_loops_cbcBCab},
	{"cbcBCba", par_nested_loops_cbcBCba},
	{"cCBbabc", par_nested_loops_cCBbabc},
	{"cCBbacb", par_nested_loops_cCBbacb},
	{"cCBbcab", par_nested_loops_cCBbcab},
	{"cCBbcba", par_nested_loops_cCBbcba},
	{"cCBabcb", par_nested_loops_cCBabcb},
	{"cCBcbab", par_nested_loops_cCBcbab},
	{"cabCBbc", par_nested_loops_cabCBbc},
	{"cabCBcb", par_nested_loops_cabCBcb},
	{"cabBCbc", par_nested_loops_cabBCbc},
	{"cabBCcb", par_nested_loops_cabBCcb},
	{"cabcCBb", par_nested_loops_cabcCBb},
	{"cabcBCb", par_nested_loops_cabcBCb},
	{"cabcbBC", par_nested_loops_cabcbBC},
	{"cabcbCB", par_nested_loops_cabcbCB},
	{"caCBbcb", par_nested_loops_caCBbcb},
	{"caBCbcb", par_nested_loops_caBCbcb},
	{"cacbCBb", par_nested_loops_cacbCBb},
	{"cacbBCb", par_nested_loops_cacbBCb}
};

